<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NQ Reversal Bot v3 (Standalone)</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-dark: #0f1115;
            --bg-card: #181b21;
            --bg-hover: #22262e;
            --primary: #6366f1;
            --primary-hover: #4f46e5;
            --accent: #10b981;
            --danger: #ef4444;
            --text-main: #f3f4f6;
            --text-muted: #9ca3af;
            --border: #2d3139;
            --glass: rgba(255, 255, 255, 0.05);
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-dark);
            color: var(--text-main);
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .app-container {
            height: 100%;
            display: flex;
            flex-direction: column;
        }

        header {
            padding: 0.8rem 1.5rem;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: var(--bg-card);
            flex-shrink: 0;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .logo h1 {
            font-size: 1.1rem;
            font-weight: 700;
            margin: 0;
        }

        .version {
            font-size: 0.7rem;
            background: var(--primary);
            padding: 0.1rem 0.4rem;
            border-radius: 4px;
            margin-left: 0.5rem;
            color: #fff;
        }

        /* KPI Bar */
        .dashboard-bar {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 0.8rem;
            padding: 0.8rem 1.5rem;
            background: var(--bg-card);
            border-bottom: 1px solid var(--border);
            flex-shrink: 0;
            overflow-x: auto;
        }

        .kpi-card {
            background: var(--bg-dark);
            padding: 0.6rem 0.8rem;
            border-radius: 6px;
            border: 1px solid var(--border);
        }

        .kpi-label {
            font-size: 0.7rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            display: block;
            margin-bottom: 0.2rem;
        }

        .kpi-value {
            font-size: 1.1rem;
            font-weight: 700;
        }

        .text-green {
            color: var(--accent);
        }

        .text-red {
            color: var(--danger);
        }

        /* Main Layout */
        main {
            flex: 1;
            display: flex;
            gap: 1rem;
            padding: 1rem 1.5rem;
            overflow: hidden;
        }

        .control-panel {
            width: 280px;
            display: flex;
            flex-direction: column;
            gap: 1rem;
            flex-shrink: 0;
            overflow-y: auto;
        }

        .results-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: var(--bg-card);
            border-radius: 8px;
            border: 1px solid var(--border);
            overflow: hidden;
        }

        .card {
            background: var(--bg-card);
            border-radius: 8px;
            border: 1px solid var(--border);
            padding: 1rem;
        }

        h2 {
            font-size: 0.85rem;
            text-transform: uppercase;
            color: var(--text-muted);
            margin-bottom: 0.8rem;
            font-weight: 600;
        }

        /* Form */
        label {
            display: block;
            font-size: 0.75rem;
            margin-bottom: 0.3rem;
            color: var(--text-muted);
        }

        input[type="number"],
        input[type="text"] {
            width: 100%;
            background: var(--bg-dark);
            border: 1px solid var(--border);
            color: var(--text-main);
            padding: 0.4rem;
            border-radius: 4px;
            font-size: 0.85rem;
            margin-bottom: 0.8rem;
        }

        input:focus {
            outline: none;
            border-color: var(--primary);
        }

        .form-row {
            display: flex;
            gap: 0.5rem;
        }

        .upload-label {
            border: 2px dashed var(--border);
            border-radius: 6px;
            padding: 1rem;
            text-align: center;
            cursor: pointer;
            background: var(--glass);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.3rem;
            margin-bottom: 1rem;
            transition: 0.2s;
        }

        .upload-label:hover {
            border-color: var(--primary);
            background: rgba(99, 102, 241, 0.1);
        }

        #file-name {
            font-size: 0.75rem;
            color: var(--accent);
            min-height: 1rem;
        }

        .toggle {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            cursor: pointer;
            margin-bottom: 0.5rem;
            font-size: 0.8rem;
        }

        .toggle input {
            display: none;
        }

        .slider {
            width: 28px;
            height: 16px;
            background: var(--border);
            border-radius: 20px;
            position: relative;
            transition: 0.3s;
            flex-shrink: 0;
        }

        .slider::before {
            content: '';
            position: absolute;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: white;
            top: 2px;
            left: 2px;
            transition: 0.3s;
        }

        input:checked+.slider {
            background: var(--primary);
        }

        input:checked+.slider::before {
            transform: translateX(12px);
        }

        .cta-button {
            width: 100%;
            background: var(--primary);
            border: none;
            color: white;
            padding: 0.8rem;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            justify-content: center;
            gap: 0.5rem;
            font-size: 0.9rem;
        }

        .cta-button:hover {
            background: var(--primary-hover);
        }

        .cta-button:disabled {
            opacity: 0.6;
            cursor: wait;
        }

        /* Trigger Stats Table (Small) */
        .stats-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.75rem;
        }

        .stats-table th {
            text-align: left;
            color: var(--text-muted);
            padding: 4px;
            border-bottom: 1px solid var(--border);
            font-weight: 500;
        }

        .stats-table td {
            padding: 4px;
            border-bottom: 1px solid #333;
        }

        /* Main Results Table */
        .results-header {
            padding: 0.8rem;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: var(--bg-hover);
        }

        .table-wrapper {
            flex: 1;
            overflow: auto;
        }

        table.main-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.8rem;
        }

        .main-table th {
            background: var(--bg-dark);
            padding: 0.6rem;
            text-align: left;
            position: sticky;
            top: 0;
            z-index: 10;
            cursor: pointer;
            user-select: none;
            border-bottom: 2px solid var(--border);
            font-weight: 600;
            color: var(--text-muted);
            transition: background 0.2s;
        }

        .main-table th:hover {
            background: #222;
            color: #fff;
        }

        .main-table th.sort-asc::after {
            content: ' â–²';
            font-size: 0.7em;
        }

        .main-table th.sort-desc::after {
            content: ' â–¼';
            font-size: 0.7em;
        }

        .main-table td {
            padding: 0.3rem 0.4rem;
            border-bottom: 1px solid var(--border);
            white-space: nowrap;
        }

        .main-table tr:hover {
            background: var(--glass);
        }

        /* Filter Row Inputs */
        .filter-input {
            width: 100%;
            padding: 2px 4px;
            font-size: 0.7rem;
            background: #222;
            border: 1px solid #444;
            color: #ddd;
            border-radius: 3px;
            margin-top: 2px;
            margin-bottom: 0;
        }

        .spinner {
            width: 14px;
            height: 14px;
            border: 2px solid #ffffff3d;
            border-top: 2px solid #fff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        .hidden {
            display: none !important;
        }
    </style>
</head>

<body>
    <div class="app-container">
        <header>
            <div class="logo">
                <span class="logo-icon">âš¡</span>
                <h1>NQ Reversal <span class="version">v3</span></h1>
            </div>
        </header>

        <div class="dashboard-bar hidden" id="dashboard">
            <div class="kpi-card">
                <span class="kpi-label">Net PnL ($)</span>
                <span class="kpi-value" id="kpi-pnl">$0.00</span>
            </div>
            <div class="kpi-card">
                <span class="kpi-label">Net PnL (Pts)</span>
                <span class="kpi-value" id="kpi-pts">0.00</span>
            </div>
            <div class="kpi-card">
                <span class="kpi-label">Win Rate</span>
                <span class="kpi-value" id="kpi-winrate">0%</span>
            </div>
            <div class="kpi-card">
                <span class="kpi-label">Profit Factor</span>
                <span class="kpi-value" id="kpi-pf">0.00</span>
            </div>
            <div class="kpi-card">
                <span class="kpi-label">Avg R:R</span>
                <span class="kpi-value" id="kpi-rr">0.00</span>
            </div>
            <div class="kpi-card">
                <span class="kpi-label">Worst Day</span>
                <span class="kpi-value" id="kpi-dd">0.00%</span>
            </div>
            <div class="kpi-card">
                <span class="kpi-label">Total Trades</span>
                <span class="kpi-value" id="kpi-count">0</span>
            </div>

        </div>

        <main>
            <section class="control-panel">
                <div class="card">
                    <h2>Configuration</h2>
                    <form id="backtest-form">
                        <label for="data-file" class="upload-label">
                            <div style="font-size:1.2rem">ðŸ“‚</div>
                            <div>Select Sierra Chart File</div>
                            <div id="file-name"></div>
                        </label>
                        <input type="file" id="data-file" name="file" accept=".txt,.csv" style="display:none" required>

                        <div class="form-row">
                            <div><label>TP (Pts)</label><input type="number" name="tp_points" value="50" step="0.25">
                            </div>
                            <div><label>SL (Pts)</label><input type="number" name="sl_points" value="10" step="0.25">
                            </div>
                        </div>

                        <div><label>Offset (Front-Run)</label><input type="number" name="offset_points" value="5"
                                step="0.25"></div>

                        <div style="margin-bottom:1rem">
                            <label class="toggle"><input type="checkbox" id="chk-hnln" checked><span
                                    class="slider"></span><span>HN / LN</span></label>
                            <label class="toggle"><input type="checkbox" id="chk-npoc" checked><span
                                    class="slider"></span><span>nPOC</span></label>
                            <label class="toggle"><input type="checkbox" id="chk-hva" checked><span
                                    class="slider"></span><span>HVA / LVA (70%)</span></label>
                            <label class="toggle"><input type="checkbox" id="chk-pday" checked><span
                                    class="slider"></span><span>Prev Day (P-HD/LD)</span></label>
                            <label class="toggle"><input type="checkbox" id="chk-dday" checked><span
                                    class="slider"></span><span>Dynamic (D-HD/LD)</span></label>
                            <label class="toggle"><input type="checkbox" id="chk-sp" checked><span
                                    class="slider"></span><span>Single Prints</span></label>
                            <label class="toggle"><input type="checkbox" id="chk-vwap" checked><span
                                    class="slider"></span><span>VWAP</span></label>
                            <label class="toggle"><input type="checkbox" id="chk-rnd" checked><span
                                    class="slider"></span><span>Round Numbers</span></label>
                            <label class="toggle"><input type="checkbox" id="chk-gap" checked><span
                                    class="slider"></span><span>Overnight Gaps</span></label>

                            <div style="margin-top: 1rem; border-top: 1px solid #333; padding-top: 0.5rem;">
                                <div style="font-size: 0.85rem; color: #888; margin-bottom: 0.5rem;">Risk / Filters
                                </div>
                                <label class="toggle"><input type="checkbox" id="chk-dist-reset"><span
                                        class="slider"></span><span>Use Distance Reset</span></label>
                                <div
                                    style="display: flex; align-items: center; justify-content: space-between; margin-top: 0.5rem;">
                                    <label style="font-size: 0.85rem;">Reset Dist (Pts)</label>
                                    <input type="number" id="inp-reset-dist" value="20" step="1"
                                        style="width: 60px; padding: 4px;">
                                </div>
                            </div>

                            <div style="margin-top: 1rem; border-top: 1px solid #333; padding-top: 0.5rem;">
                                <div style="font-size: 0.85rem; color: #888; margin-bottom: 0.5rem;">Strategy
                                    Enhancements
                                </div>
                                <label class="toggle"><input type="checkbox" id="chk-or-filter"><span
                                        class="slider"></span><span>OR Filter (30m)</span></label>
                                <label class="toggle"><input type="checkbox" id="chk-dynamic-tp"><span
                                        class="slider"></span><span>Dynamic TP</span></label>
                            </div>
                            <!-- Debug Mode -->
                            <div style="margin-top: 1rem; border-top: 1px solid #333; padding-top: 0.5rem;">
                                <label class="toggle"><input type="checkbox" id="chk-debug"><span
                                        class="slider"></span><span>Enable Debug Log (Console)</span></label>
                            </div>
                        </div>

                        <button type="submit" id="run-btn" class="cta-button">
                            <span>Run Backtest</span>
                            <div class="spinner hidden"></div>
                        </button>
                    </form>
                </div>

                <div id="debug-info"
                    style="font-size: 0.7rem; color: #aaa; text-align: center; margin-top: -0.5rem; margin-bottom: 0.5rem;">
                    Status: Ready
                </div>

                <div class="card" id="stats-container" style="display:none; flex-direction:column; margin-top: auto;">
                    <h2>Trigger Stats</h2>
                    <div style="width:100%;">
                        <table class="stats-table" style="width:100%; border: 1px solid #333;">
                            <thead>
                                <tr style="background:#222; color:#fff;">
                                    <th>Level</th>
                                    <th>#</th>
                                    <th>Win%</th>
                                    <th>PnL $</th>
                                </tr>
                            </thead>
                            <tbody id="stats-body"></tbody>
                        </table>
                    </div>
                </div>
            </section>

            <section class="results-panel hidden" id="results-panel">
                <div class="results-header">
                    <h2>Trade Log</h2>
                    <div style="font-size:0.75rem; color:var(--text-muted)">Click headers to sort</div>
                </div>
                <div class="table-wrapper">
                    <table class="main-table" id="results-table">
                        <thead>
                            <tr id="sort-headers">
                                <th data-key="date">Date</th>
                                <th data-key="entryTime">Enter</th>
                                <th data-key="dir">Dir</th>
                                <th data-key="level">Level</th>
                                <th data-key="trigPrice">Trig</th>
                                <th data-key="entry">Entry</th>
                                <th data-key="exitTime">Exit</th>
                                <th data-key="exit">Exit $$</th>
                                <th data-key="mfe">Max Profit</th>
                                <th data-key="pnl">PnL Pts</th>
                                <th data-key="pnlUsd">PnL $</th>
                            </tr>

                        </thead>
                        <tbody id="trade-body"></tbody>
                    </table>
                </div>
                <!-- Debug Log Section (New) -->
                <div id="debug-log-container" style="margin-top: 1.5rem; display: none;">
                    <div
                        style="background: rgba(30,30,40,0.9); border: 1px solid #444; border-radius: 8px; overflow: hidden;">
                        <div
                            style="padding: 10px; background: #2a2a35; border-bottom: 1px solid #444; font-weight: bold; color: #ccc; display: flex; justify-content: space-between;">
                            <span>Decision Log (Debug)</span>
                            <span style="font-size: 0.8em; opacity: 0.7;">Shows last 1000 events</span>
                        </div>
                        <div style="max-height: 400px; overflow-y: auto;">
                            <table id="debug-table"
                                style="width: 100%; border-collapse: collapse; font-family: monospace; font-size: 0.8rem; color: #bababa;">
                                <thead style="position: sticky; top: 0; background: #222; text-align: left;">
                                    <tr>
                                        <th style="padding: 8px;">Date</th>
                                        <th style="padding: 8px;">Time</th>
                                        <th style="padding: 8px;">Event</th>
                                        <th style="padding: 8px;">Details</th>
                                    </tr>
                                </thead>
                                <tbody id="debug-body"></tbody>
                            </table>
                        </div>
                    </div>
                </div>
            </section>
        </main>
    </div>

    <script>
        class DateTime {
            constructor(d, t) {
                const p = d.trim().split(/[-/]/);
                let Y, M, D;
                if (p[0].length === 4) { [Y, M, D] = p; } else { [D, M, Y] = p; }
                const [h, m, s] = t.trim().split(':');
                this.date = new Date(+Y, M - 1, +D, +h, +m, parseFloat(s));
                this.ts = this.date.getTime();
            }
            getDateStr() { return this.date.toISOString().split('T')[0]; }
            getTimeStr() { return this.date.toLocaleTimeString(); }
        }

        function parseFile(file) {
            return new Promise((res, rej) => {
                const r = new FileReader();
                r.onload = e => {
                    const lines = e.target.result.trim().split('\n');
                    let hIdx = 0;
                    for (let i = 0; i < Math.min(lines.length, 50); i++)
                        if (lines[i].toLowerCase().includes('date') && lines[i].toLowerCase().includes('time')) { hIdx = i; break; }

                    const head = lines[hIdx].split(',').map(s => s.trim().toLowerCase());
                    const map = {}; head.forEach((c, i) => map[c] = i);
                    const col = (ns) => { for (let n of ns) if (map[n] !== undefined) return map[n]; return -1; };
                    const C = { d: col(['date']), t: col(['time']), h: col(['high']), l: col(['low']), o: col(['open']), c: col(['close', 'last']), v: col(['vwap', 'volume weighted average price']) };

                    if (C.d < 0) return rej("Invalid Format");
                    const data = [];
                    for (let i = hIdx + 1; i < lines.length; i++) {
                        const row = lines[i].split(',');
                        if (row.length < head.length) continue;
                        try {
                            data.push({
                                dt: new DateTime(row[C.d], row[C.t]),
                                o: +row[C.o], h: +row[C.h], l: +row[C.l], c: +row[C.c], v: C.v > -1 ? +row[C.v] : null
                            });
                        } catch (x) { }
                    }
                    res(data);
                };
                r.readAsText(file);
            });
        }

        // TPO Builder Helper Class
        class TPOBuilder {
            constructor() {
                this.counts = {};
                this.totalTPO = 0;
                this.minP = Infinity;
                this.maxP = -Infinity;
            }
            add(b) {
                const start = Math.floor(b.l * 4);
                const end = Math.floor(b.h * 4);
                for (let p = start; p <= end; p++) {
                    this.counts[p] = (this.counts[p] || 0) + 1;
                    if (p < this.minP) this.minP = p;
                    if (p > this.maxP) this.maxP = p;
                    this.totalTPO++;
                }
            }
            calc() {
                if (this.totalTPO === 0) return { poc: 0, hva: 0, lva: 0 };

                const prices = [];
                for (let p = this.minP; p <= this.maxP; p++) {
                    if (this.counts[p]) prices.push(p);
                }

                let maxC = -1, pocTick = 0;
                for (const p of prices) {
                    if (this.counts[p] > maxC) { maxC = this.counts[p]; pocTick = p; }
                }

                const target = this.totalTPO * 0.7;
                let current = maxC;
                let upIdx = prices.indexOf(pocTick) + 1;
                let dnIdx = prices.indexOf(pocTick) - 1;

                while (current < target) {
                    const upVol = (upIdx < prices.length) ? this.counts[prices[upIdx]] : 0;
                    const dnVol = (dnIdx >= 0) ? this.counts[prices[dnIdx]] : 0;

                    if (upVol === 0 && dnVol === 0) break;

                    if (upVol >= dnVol) {
                        current += upVol;
                        upIdx++;
                    } else {
                        current += dnVol;
                        dnIdx--;
                    }
                }

                return {
                    poc: pocTick / 4,
                    hva: prices[Math.min(upIdx - 1, prices.length - 1)] / 4,
                    lva: prices[Math.max(dnIdx + 1, 0)] / 4
                };
            }
        }

        class Strategy {
            constructor(data, cfg) { this.d = data; this.c = cfg; this.T = []; this.debugLogs = []; }
            run() {
                const days = [...new Set(this.d.map(x => x.dt.getDateStr()))].sort();
                let pH = null, pL = null, pClose = 0, prevClosePrice = null; // pClose is TS, prevClosePrice is Price
                this.spRepo = []; // Persistence for Single Prints
                this.gapRepo = []; // Persistence for Unfilled Gaps

                days.forEach(day => {
                    const bars = this.d.filter(b => b.dt.getDateStr() === day);
                    const rth = bars.filter(b => { const h = b.dt.date.getHours(), m = b.dt.date.getMinutes(); return (h * 60 + m) >= 570 && (h * 60 + m) < 1020; }); // 09:30-17:00

                    if (!rth.length) return;
                    let lvls = [];

                    if (pH !== null) {
                        const openTs = rth[0].dt.ts;

                        // --- NIGHT SESSION ANALYSIS ---
                        const night = this.d.filter(b => b.dt.ts > pClose && b.dt.ts < openTs);

                        // Gap Detection
                        if (this.c.gap && night.length > 0) {
                            // 1. Check existing Gaps - Did night session fill them?
                            // "Filled" means price touched the Gap's TARGET (the original pClose of that gap).
                            // Gap Object: { p: OpenPrice, target: OriginalClose, d: Dir, date: DateStr }

                            const nightH = Math.max(...night.map(b => b.h));
                            const nightL = Math.min(...night.map(b => b.l));

                            // Filter OUT filled gaps
                            this.gapRepo = this.gapRepo.filter(g => {
                                let filled = false;
                                if (g.d === 'LONG') { // Gap Up, Target is Below
                                    if (nightL <= g.target) filled = true;
                                } else { // Gap Down, Target is Above
                                    if (nightH >= g.target) filled = true;
                                }
                                return !filled;
                            });

                            // 2. Detect NEW Gap (Today's Night Open vs Yesterday's Close)
                            const nightOpenBar = night[0];
                            const nightOpen = nightOpenBar.o;
                            // Gap Up: Open > pClose
                            // Gap Down: Open < pClose
                            let newGap = null;
                            if (prevClosePrice !== null) {
                                if (nightOpen > prevClosePrice) {
                                    newGap = { p: nightOpen, target: prevClosePrice, d: 'LONG', date: day, n: 'GAP' }; // Support
                                } else if (nightOpen < prevClosePrice) {
                                    newGap = { p: nightOpen, target: prevClosePrice, d: 'SHORT', date: day, n: 'GAP' }; // Resistance
                                }
                            }

                            // 3. Check if NEW Gap was immediately filled in Night Session
                            if (newGap) {
                                let filledNow = false;
                                if (newGap.d === 'LONG') {
                                    if (nightL <= newGap.target) filledNow = true;
                                } else {
                                    if (nightH >= newGap.target) filledNow = true;
                                }

                                if (!filledNow) {
                                    this.gapRepo.push(newGap);
                                }
                            }
                        }

                        if (night.length) {
                            const hN = Math.max(...night.map(b => b.h));
                            const lN = Math.min(...night.map(b => b.l));

                            // --- TPO HELPER ---
                            const calcTPO = (bars) => {
                                const counts = {};
                                bars.forEach(b => {
                                    for (let p = Math.floor(b.l * 4); p <= Math.floor(b.h * 4); p++)
                                        counts[p] = (counts[p] || 0) + 1;
                                });
                                const sortedPrices = Object.keys(counts).map(Number).sort((a, b) => a - b);
                                const totalTPO = Object.values(counts).reduce((a, b) => a + b, 0);
                                let maxC = -1, pocTick = 0;
                                for (const p of sortedPrices) { if (counts[p] > maxC) { maxC = counts[p]; pocTick = p; } }

                                const target = totalTPO * 0.7;
                                let current = maxC, upIdx = sortedPrices.indexOf(pocTick) + 1, dnIdx = sortedPrices.indexOf(pocTick) - 1;

                                while (current < target) {
                                    const upVol = (upIdx < sortedPrices.length) ? counts[sortedPrices[upIdx]] : 0;
                                    const dnVol = (dnIdx >= 0) ? counts[sortedPrices[dnIdx]] : 0;
                                    if (upVol === 0 && dnVol === 0) break;
                                    if (upVol >= dnVol) { current += upVol; upIdx++; if (dnVol > 0 && current < target) { current += dnVol; dnIdx--; } }
                                    else { current += dnVol; dnIdx--; }
                                }
                                return {
                                    hva: sortedPrices[Math.min(upIdx - 1, sortedPrices.length - 1)] / 4,
                                    lva: sortedPrices[Math.max(dnIdx + 1, 0)] / 4,
                                    poc: pocTick / 4
                                };
                            };

                            // 1. Standard
                            const tpoStandard = calcTPO(night);

                            // 2. Globez (18:00 Start approx)
                            let globezStartTs = pClose + 3600000;
                            if (pClose === 0 && night.length > 0) {
                                // First day in file. Try to detect session break.
                                // Look for gap > 45 mins.
                                let lastTs = night[0].dt.ts;
                                for (let i = 1; i < night.length; i++) {
                                    if (night[i].dt.ts - lastTs > 45 * 60 * 1000) {
                                        globezStartTs = night[i].dt.ts;
                                        break;
                                    }
                                    lastTs = night[i].dt.ts;
                                }
                                // If no gap, assume night[0] IS the Globez start (if hour is ~18:00)
                                if (globezStartTs === 3600000) { // Unchanged
                                    if (night[0].dt.date.getHours() >= 17) globezStartTs = night[0].dt.ts;
                                }
                            }

                            const nightGlobez = night.filter(b => b.dt.ts >= globezStartTs);
                            // Fallback to Standard if Globez empty
                            const tpoGlobez = nightGlobez.length ? calcTPO(nightGlobez) : tpoStandard;

                            // USE GLOBEZ (18:00 Start) to match standard trader profiles
                            const { hva, lva, poc } = tpoGlobez;

                            if (this.c.npoc) lvls.push({ n: 'nPOC', p: poc, a: 1, d: 'BOTH' });
                            if (this.c.hnln) {
                                lvls.push({ n: 'HN', p: hN, a: 1, d: 'SHORT' });
                                lvls.push({ n: 'LN', p: lN, a: 1, d: 'LONG' });
                            }
                            if (this.c.hva) {
                                lvls.push({ n: 'HVA', p: hva, a: 1, d: 'SHORT' });
                                lvls.push({ n: 'LVA', p: lva, a: 1, d: 'LONG' });
                            }
                        }

                        // --- PREVIOUS DAY LEVELS (Static) ---
                        if (this.c.pday) {
                            lvls.push({ n: 'P-HD', p: pH, a: 1, d: 'SHORT' });
                            lvls.push({ n: 'P-LD', p: pL, a: 1, d: 'LONG' });
                        }

                        // --- SINGLE PRINTS (SP) LOGIC ---
                        if (this.c.sp && night.length > 0) {
                            const spMap = {}; // Price -> Set(PeriodIndex)
                            // Group Night Session into 30m Buckets
                            const startTs = night[0].dt.ts;
                            night.forEach(b => {
                                const diffMs = b.dt.ts - startTs;
                                const pIdx = Math.floor(diffMs / (30 * 60 * 1000)); // 0, 1, 2...
                                for (let p = Math.floor(b.l * 4); p <= Math.floor(b.h * 4); p++) {
                                    if (!spMap[p]) spMap[p] = new Set();
                                    spMap[p].add(pIdx);
                                }
                            });

                            // Identify Single Prints (Count === 1)
                            const singles = [];
                            Object.keys(spMap).forEach(k => {
                                if (spMap[k].size === 1) singles.push(Number(k));
                            });
                            singles.sort((a, b) => a - b);

                            // Cluster them into Zones
                            // Increase min size to 8 ticks (2 points) to reduce noise
                            if (singles.length > 0) {
                                let clusters = [];
                                let currentCluster = [singles[0]];

                                for (let i = 1; i < singles.length; i++) {
                                    if (singles[i] === singles[i - 1] + 1) {
                                        currentCluster.push(singles[i]);
                                    } else {
                                        if (currentCluster.length >= 8) clusters.push(currentCluster);
                                        currentCluster = [singles[i]];
                                    }
                                }
                                if (currentCluster.length >= 8) clusters.push(currentCluster);

                                // Create Levels from Clusters
                                clusters.forEach(c => {
                                    const botP = c[0] / 4;
                                    const topP = c[c.length - 1] / 4;
                                    // Unified Name 'SP'
                                    // Front-run 5 pts, Fixed SL 10, TP 50
                                    // We define specific props for this level type
                                    lvls.push({ n: 'SP', p: topP, a: 1, d: 'LONG', props: { off: 5, sl: 10, tp: 50 } });
                                    lvls.push({ n: 'SP', p: botP, a: 1, d: 'SHORT', props: { off: 5, sl: 10, tp: 50 } });
                                });
                            }
                        } // End SP Logic

                        // --- ADD ACTIVE GAPS TO LEVELS ---
                        if (this.c.gap && this.gapRepo.length > 0) {
                            this.gapRepo.forEach(g => {
                                // Inherit global Offset unless specific logic needed
                                // User mentioned "Cancel the 2 pts... maybe 25530" which is +5. 
                                // We will rely on global offset or default props if we want.
                                // For now use standard level struct.
                                lvls.push({ n: 'GAP', p: g.p, a: 1, d: g.d, gapTarget: g.target });
                            });
                        }

                    }


                    this.sim(rth, lvls);
                    pH = Math.max(...rth.map(b => b.h)); pL = Math.min(...rth.map(b => b.l));
                    pClose = rth[rth.length - 1].dt.ts;
                    // Note: pClose is TS here? No, in sim() we pushed ex. Waiting.
                    // Original code: pClose = rth[rth.length - 1].dt.ts; 
                    // WAIT, pClose should be PRICE for Gap Detection!
                    // Line 189 in original: pClose = rth[rth.length - 1].dt.ts; <- This looks like a BUG in original or I misread.
                    // Let's check constructor/usage. 
                    // Usage: const night = this.d.filter(b => b.dt.ts > pClose ... 
                    // Yes, pClose IS TIMESTAMP in the original code logic for filtering time.
                    // BUT for GAP Price we need the PRICE.
                    // I need to track pClosePrice separately or extract it.

                    // Re-reading original line 50: let pH = null, pL = null, pClose = 0; (Initialized to 0)
                    // Re-reading original line 189: pClose = rth[rth.length - 1].dt.ts; (Updated to TS)

                    // I need to capture the CLOSE PRICE of the last bar.
                    if (rth.length) {
                        this.prevClosePrice = rth[rth.length - 1].c;
                        pClose = rth[rth.length - 1].dt.ts;
                    } else {
                        // First loop day, pClose is 0.
                    }

                    // --- POST-SESSION SP UPDATE ---
                    if (this.c.sp) {
                        // Remove burned
                        this.spRepo = this.spRepo.filter(l => l.a === 1);
                        // Add Today's RTH SPs (for tomorrow)
                        if (rth.length > 0) {
                            const rthSPs = this.getSPs(rth);
                            rthSPs.forEach(l => {
                                this.spRepo.push({ ...l, props: { off: 5, sl: 10, tp: 50 }, a: 1 });
                            });
                        }
                    }

                    // --- POST-SESSION GAP CLEANUP (Day Session Update) ---
                    if (this.c.gap && this.gapRepo.length > 0) {
                        // Check if Day Session filled any gaps
                        const dayH = Math.max(...rth.map(b => b.h));
                        const dayL = Math.min(...rth.map(b => b.l));

                        this.gapRepo = this.gapRepo.filter(g => {
                            let filled = false;
                            if (g.d === 'LONG') { // Support Level
                                // Gap Filled if price went DOWN to target (pClose)
                                if (dayL <= g.target) filled = true;
                            } else { // Resistance
                                if (dayH >= g.target) filled = true;
                            }
                            return !filled;
                        });
                    }

                });
                return this.T;
            }

            sim(bars, lvls) {
                let pos = null;
                let sessH = -Infinity, sessL = Infinity;

                // Developing TPO State
                const dayTPO = new TPOBuilder();

                for (let b of bars) {
                    const tMin = b.dt.date.getHours() * 60 + b.dt.date.getMinutes();

                    // --- UPDATE DEVELOPING TPO (Bar Completion) ---
                    // We update at START of processing this bar (Simulating "Real Time" as bar forms? 
                    // No, usually TPO updates AS price prints. 
                    // For backtest accuracy on 1-min bars:
                    // ideally we treat the levels as updating continuously.
                    // But we can simply update with THIS bar's range, then calculate levels for THIS bar's trade logic?
                    // OR do we trade against levels calculated from PRIOR bars?
                    // User said "Developing", implying real-time.
                    // Decision: Add bar to TPO -> Update Levels -> Check Trades.
                    // This implies we are trading against the profile INCLUDING this bar's activity so far.
                    // Since we use 'path' (intra-bar), the level would shift intra-bar. 
                    // Approximation: Update TPO with this bar, set 'updated' = tMin.

                    dayTPO.add(b);
                    const dTPO = dayTPO.calc();

                    // Update Dynamic TPO Levels
                    // Helper to update/create
                    const updateDynLvl = (name, price, dir) => {
                        let l = lvls.find(x => x.n === name);
                        if (!l) {
                            // Create new
                            lvls.push({ n: name, p: price, a: 1, d: dir, updated: tMin });
                        } else {
                            // Update existing only if price changed significantly?
                            if (l.p !== price) {
                                l.p = price;
                                l.updated = tMin; // Reset 5-min timer
                            }
                        }
                    };

                    if (this.c.npoc) updateDynLvl('d-POC', dTPO.poc, 'BOTH');
                    if (this.c.hva) {
                        updateDynLvl('d-HVA', dTPO.hva, 'SHORT'); // Value High -> Short
                        updateDynLvl('d-LVA', dTPO.lva, 'LONG');  // Value Low -> Long
                    }

                    // 0. Force Close at 16:55 (1015 min)
                    if (pos && tMin >= 1015) {
                        const ex = b.o;
                        const st = 'C';
                        const rawPnlPts = pos.d === 'LONG' ? ex - pos.en : pos.en - ex;
                        const ticksSlip = this.c.slip * 0.25;
                        const slipCostPts = ticksSlip; // Slip on Market Close
                        const netPnlPts = rawPnlPts - slipCostPts;
                        const grossUsd = rawPnlPts * 20;
                        const totalComm = this.c.comm * 2;
                        const slipUsd = slipCostPts * 20;
                        const netUsd = grossUsd - totalComm - slipUsd;

                        this.T.push({
                            date: b.dt.getDateStr(), entryTime: pos.tStr, dir: pos.d, level: pos.ln,
                            trigPrice: pos.tpP, entry: pos.en, exitTime: b.dt.getTimeStr(), exit: ex,
                            pnl: netPnlPts, pnlUsd: netUsd, status: st,
                            mfe: pos.maxFav,
                            details: { gross: grossUsd, comm: totalComm, slip: slipUsd }
                        });
                        pos = null;
                    }

                    // 1. Construct Path
                    let path = [];
                    path.push({ p: b.o, t: b.dt.getTimeStr() });
                    if (b.c >= b.o) {
                        path.push({ p: b.l, t: b.dt.getTimeStr() });
                        path.push({ p: b.h, t: b.dt.getTimeStr() });
                    } else {
                        path.push({ p: b.h, t: b.dt.getTimeStr() });
                        path.push({ p: b.l, t: b.dt.getTimeStr() });
                    }
                    path.push({ p: b.c, t: b.dt.getTimeStr() });

                    // 2. Process Segments
                    for (let i = 0; i < path.length - 1; i++) {
                        let p1 = path[i].p;
                        const p2 = path[i + 1].p;
                        let tStr = path[i + 1].t;

                        // --- DYNAMIC HD/LD UPDATES (Intra-Bar) ---
                        if (this.c.tpo_day) {
                            if (path[i].p > sessH) {
                                sessH = path[i].p;
                                // Use separate D-HD for Dynamic Day High
                                let hd = lvls.find(x => x.n === 'D-HD');
                                if (this.c.dday) {
                                    if (!hd) { hd = { n: 'D-HD', p: sessH, a: 1, d: 'SHORT', updated: tMin }; lvls.push(hd); }
                                    else { hd.p = sessH; hd.a = 1; hd.updated = tMin; }
                                }
                            }
                            if (path[i].p < sessL) {
                                sessL = path[i].p;
                                let ld = lvls.find(x => x.n === 'D-LD');
                                if (this.c.dday) {
                                    if (!ld) { ld = { n: 'D-LD', p: sessL, a: 1, d: 'LONG', updated: tMin }; lvls.push(ld); }
                                    else { ld.p = sessL; ld.a = 1; ld.updated = tMin; }
                                }
                            }
                        }

                        // --- OPENING RANGE LOGIC (09:30 - 10:00) ---
                        // RTH Starts 09:30 (570 min). OR Ends 10:00 (600 min).
                        let orH = null, orL = null;

                        // We need to calculate OR High/Low dynamically if we are past 10:00
                        if (this.c.orFilter && tMin >= 600) {
                            // Find 09:30-10:00 bars for this day.
                            const orBars = bars.filter(x => {
                                const t = x.dt.date.getHours() * 60 + x.dt.date.getMinutes();
                                return t >= 570 && t < 600;
                            });
                            if (orBars.length) {
                                orH = Math.max(...orBars.map(x => x.h));
                                orL = Math.min(...orBars.map(x => x.l));
                            }
                        }

                        // --- DISTANCE RESET LOGIC (Unlocking) ---
                        if (this.c.useDistReset) {
                            lvls.forEach(l => {
                                if (l.locked) {
                                    const dist = Math.abs(p1 - l.p); // Use current path price
                                    if (dist >= this.c.distReset) {
                                        l.locked = false;
                                        // console.log(`Unlocked ${l.n} at ${tStr} (Dist: ${dist.toFixed(2)})`);
                                    }
                                }
                            });
                        }

                        // INTRA-BAR RESCAN LOOP
                        let segmentDone = false;
                        while (!segmentDone) {
                            segmentDone = true;

                            // A. Check Exits
                            if (pos) {
                                const segMax = Math.max(p1, p2);
                                const segMin = Math.min(p1, p2);

                                if (pos.d === 'LONG') {
                                    pos.maxFav = Math.max(pos.maxFav, segMax - pos.en);
                                } else {
                                    pos.maxFav = Math.max(pos.maxFav, pos.en - segMin);
                                }

                                let ex = null, st = null;
                                if (pos.d === 'LONG') {
                                    if (p1 <= pos.sl) { ex = p1; st = 'L'; }
                                    else if (p1 >= pos.tp) { ex = p1; st = 'W'; }
                                    else {
                                        const hitSL = (pos.sl >= segMin && pos.sl <= segMax);
                                        const hitTP = (pos.tp >= segMin && pos.tp <= segMax);
                                        if (hitSL) { ex = pos.sl; st = 'L'; }
                                        else if (hitTP) { ex = pos.tp; st = 'W'; }
                                    }
                                } else {
                                    if (p1 >= pos.sl) { ex = p1; st = 'L'; }
                                    else if (p1 <= pos.tp) { ex = p1; st = 'W'; }
                                    else {
                                        const hitSL = (pos.sl >= segMin && pos.sl <= segMax);
                                        const hitTP = (pos.tp >= segMin && pos.tp <= segMax);
                                        if (hitSL) { ex = pos.sl; st = 'L'; }
                                        else if (hitTP) { ex = pos.tp; st = 'W'; }
                                    }
                                }

                                if (ex !== null) {
                                    const rawPnlPts = pos.d === 'LONG' ? ex - pos.en : pos.en - ex;
                                    const ticksSlip = this.c.slip * 0.25;
                                    let slipCostPts = 0;
                                    if (st === 'L') slipCostPts = ticksSlip;
                                    const netPnlPts = rawPnlPts - slipCostPts;
                                    const grossUsd = rawPnlPts * 20;
                                    const totalComm = this.c.comm * 2;
                                    const slipUsd = slipCostPts * 20;
                                    const netUsd = grossUsd - totalComm - slipUsd;

                                    this.T.push({
                                        date: b.dt.getDateStr(), entryTime: pos.tStr, dir: pos.d, level: pos.ln,
                                        trigPrice: pos.tpP, entry: pos.en, exitTime: tStr, exit: ex,
                                        pnl: netPnlPts, pnlUsd: netUsd, status: st,
                                        mfe: pos.maxFav,
                                        details: { gross: grossUsd, comm: totalComm, slip: slipUsd }
                                    });

                                    // --- DISTANCE RESET LOGIC (Locking) ---
                                    // If SL Hit and Feature Enabled for specific levels
                                    if (st === 'L' && this.c.useDistReset) {
                                        // Include new Dynamic TPO levels in locking logic
                                        const targetTypes = ['VWAP', 'nPOC', 'mPOC', 'RN', 'd-POC'];
                                        const levelObj = lvls.find(l => l.n === pos.ln || (l.n.startsWith('RN') && pos.ln.startsWith('RN')));

                                        if (levelObj && (targetTypes.includes(levelObj.n) || levelObj.n.startsWith('RN'))) {
                                            levelObj.locked = true;
                                            // console.log(`Locked ${levelObj.n} at ${b.dt.getTimeStr()}`);
                                        }
                                    }

                                    // Burn Logic for Static Levels and Semi-Dynamic
                                    const l = lvls.find(x => x.n === pos.ln);
                                    if (l && st === 'L') {
                                        const burnList = ['P-HD', 'P-LD', 'HN', 'LN'];
                                        if (burnList.includes(l.n)) {
                                            l.a = 0; // Disable level
                                        }
                                    }
                                    pos = null;

                                    // RESCAN LOGIC
                                    if (Math.abs(ex - p2) > 0.01) {
                                        p1 = ex;
                                        segmentDone = false;
                                        continue;
                                    }
                                }
                            }

                            // B. Check Entries
                            const currentMin = b.dt.date.getHours() * 60 + b.dt.date.getMinutes();
                            if (!pos && currentMin < 960) {
                                let active = lvls.filter(x => x.a);
                                // VWAP/Round Logic
                                if (this.c.vwap && b.v) {
                                    // 15 Minute Guard for VWAP (Don't trade first 15 mins 09:30-09:45)
                                    // User Deviation: Ignore VWAP in first 15 mins.
                                    if (currentMin >= 585) {
                                        let v = active.find(x => x.n === 'VWAP');
                                        if (!v && lvls.find(x => x.n === 'VWAP')) v = lvls.find(x => x.n === 'VWAP');
                                        if (!v) { v = { n: 'VWAP', p: b.v, a: 1, d: 'BOTH' }; lvls.push(v); active.push(v); }
                                        else { v.p = b.v; if (!active.includes(v)) active.push(v); }
                                    }
                                }
                                const minP = Math.min(p1, p2), maxP = Math.max(p1, p2);
                                if (this.c.rnd) {
                                    const startR = Math.ceil(minP / 100) * 100;
                                    for (let r = startR; r <= maxP; r += 100) {
                                        active.push({ n: 'Round', p: r, a: 1, d: 'BOTH' });
                                    }
                                }

                                let potentials = [];
                                for (let l of active) {
                                    // 2. Dynamic Level Settlement Rule (User Deviation)
                                    // If D-HD, D-LD, d-POC, d-HVA, d-LVA -> Must be at least 5 mins old.
                                    const dynLevels = ['D-HD', 'D-LD', 'd-POC', 'd-HVA', 'd-LVA'];
                                    if (dynLevels.includes(l.n)) {
                                        // If updated undefined (legacy), assume okay. If defined, check diff.
                                        if (l.updated !== undefined && (currentMin - l.updated < 5)) continue;
                                    }

                                    // Determine effective offset for this level
                                    const effectiveOffset = (l.props && l.props.off !== undefined) ? l.props.off : this.c.off;

                                    const sT = l.p - effectiveOffset;
                                    const lT = l.p + effectiveOffset;

                                    // Standard Logic: Fade the Level
                                    // If coming from BELOW (Up Move) -> SHORT
                                    // If coming from ABOVE (Down Move) -> LONG

                                    if (l.d === 'BOTH') {
                                        // BOTH means we treat sT and lT as active lines for BOTH directions

                                        // Check Lower Band (sT)
                                        if (p1 < sT && p2 >= sT) potentials.push({ t: sT, type: 'SHORT', lvl: l }); // Fade Up
                                        if (p1 > sT && p2 <= sT) potentials.push({ t: sT, type: 'LONG', lvl: l });  // Fade Down (Support)

                                        // Check Upper Band (lT)
                                        if (p1 < lT && p2 >= lT) potentials.push({ t: lT, type: 'SHORT', lvl: l }); // Fade Up (Resistance)
                                        if (p1 > lT && p2 <= lT) potentials.push({ t: lT, type: 'LONG', lvl: l });  // Fade Down
                                    } else {
                                        // Directional Levels (Strict)
                                        if (l.d === 'SHORT' && p1 < sT && p2 >= sT) {
                                            potentials.push({ t: sT, type: 'SHORT', lvl: l });
                                        }
                                        if (l.d === 'LONG' && p1 > lT && p2 <= lT) {
                                            potentials.push({ t: lT, type: 'LONG', lvl: l });
                                        }
                                    }
                                }
                                potentials.sort((a, b) => (p1 < p2) ? (a.t - b.t) : (b.t - a.t));

                                if (potentials.length) {
                                    if (this.c.debug) {
                                        this.debugLogs.push({
                                            d: b.dt.getDateStr(), t: b.dt.getTimeStr(), e: 'Check',
                                            m: `Potentials: ${potentials.map(x => `${x.type} @ ${x.t} (Lvl: ${x.lvl.n})`).join(', ')}`
                                        });
                                    }
                                    const hit = potentials[0];
                                    // Check if Locked
                                    if (hit.lvl.locked) {
                                        // console.log(`Skipped Locked Level ${hit.lvl.n} at ${Math.max(p1,p2)}`);
                                    } else {
                                        // --- OR FILTER CHECK ---
                                        let allowed = true;
                                        if (this.c.orFilter && orH !== null && orL !== null) {
                                            if (hit.type === 'SHORT' && hit.t > orH) { allowed = false; if (this.c.debug) console.log(`  -> Filtered by OR (Short > ${orH})`); }
                                            if (hit.type === 'LONG' && hit.t < orL) { allowed = false; if (this.c.debug) console.log(`  -> Filtered by OR (Long < ${orL})`); }
                                        }

                                        if (allowed) {
                                            if (this.c.debug) console.log(`  -> TRADE TAKEN: ${hit.type} @ ${hit.t} (Lvl: ${hit.lvl.n})`);
                                            let calcTp = this.c.tp;
                                            let calcSl = this.c.sl;

                                            // --- DYNAMIC TP LOGIC ---
                                            if (this.c.dynamicTP) {
                                                let bestDist = Infinity;
                                                for (let l of active) {
                                                    if (l.n === hit.lvl.n) continue;
                                                    let dist = Infinity;
                                                    if (hit.type === 'LONG' && l.p > hit.t) dist = l.p - hit.t;
                                                    else if (hit.type === 'SHORT' && l.p < hit.t) dist = hit.t - l.p;

                                                    if (dist > 0 && dist < bestDist) bestDist = dist;
                                                }
                                                if (bestDist !== Infinity) calcTp = bestDist;
                                            }

                                            // --- CUSTOM PROPS OVERRIDE (SP) ---
                                            if (hit.lvl.props) {
                                                if (hit.lvl.props.sl !== undefined) calcSl = hit.lvl.props.sl;
                                                if (hit.lvl.props.tp !== undefined) calcTp = hit.lvl.props.tp; // Fixed TP overrides Dynamic
                                            }
                                            pos = {
                                                d: hit.type,
                                                en: hit.t,
                                                sl: hit.type === 'LONG' ? hit.t - calcSl : hit.t + calcSl,
                                                tp: hit.type === 'LONG' ? hit.t + calcTp : hit.t - calcTp,
                                                ln: hit.lvl.n,
                                                tpP: hit.lvl.p,
                                                tStr: tStr,
                                                maxFav: 0
                                            };

                                            // STRICT BURN LOGIC FOR SP
                                            if (hit.lvl.n === 'SP') {
                                                hit.lvl.a = 0;
                                            }

                                            p1 = pos.en;
                                            segmentDone = false;

                                        }
                                    }
                                }
                            } // end while
                        } // end segment
                    }
                }
            }
            getSPs(bars) {
                if (!bars || !bars.length) return [];
                const spMap = {};
                const startTs = bars[0].dt.ts;
                bars.forEach(b => {
                    const diffMs = b.dt.ts - startTs;
                    const pIdx = Math.floor(diffMs / (30 * 60 * 1000));
                    for (let p = Math.floor(b.l * 4); p <= Math.floor(b.h * 4); p++) {
                        if (!spMap[p]) spMap[p] = new Set();
                        spMap[p].add(pIdx);
                    }
                });

                const singles = [];
                Object.keys(spMap).forEach(k => { if (spMap[k].size === 1) singles.push(Number(k)); });
                singles.sort((a, b) => a - b);

                let clusters = [];
                if (singles.length > 0) {
                    let currentCluster = [singles[0]];
                    for (let i = 1; i < singles.length; i++) {
                        if (singles[i] === singles[i - 1] + 1) currentCluster.push(singles[i]);
                        else {
                            if (currentCluster.length >= 8) clusters.push(currentCluster);
                            currentCluster = [singles[i]];
                        }
                    }
                    if (currentCluster.length >= 8) clusters.push(currentCluster);
                }

                const res = [];
                clusters.forEach(c => {
                    const botP = c[0] / 4;
                    const topP = c[c.length - 1] / 4;
                    res.push({ n: 'SP', p: topP, a: 1, d: 'LONG' });
                    res.push({ n: 'SP', p: botP, a: 1, d: 'SHORT' });
                });
                return res;
            }
        }

        // UI Handlers
        document.addEventListener('DOMContentLoaded', () => {
            let currentData = [];
            let currentSort = { key: 'date', dir: 'desc' }; // Default DESC

            const render = (res, logs) => {
                // Initial Sort
                res.sort((a, b) => {
                    if (a.date < b.date) return 1;
                    if (a.date > b.date) return -1;
                    return 0; // Secondary sort by time?
                });

                // Sync Header Arrows
                document.querySelectorAll('#sort-headers th').forEach(th => {
                    th.classList.remove('sort-asc', 'sort-desc');
                    if (th.dataset.key === currentSort.key) th.classList.add('sort-' + currentSort.dir);
                });

                currentData = res;
                updateTable(res);
                updateKPI(res);
                if (logs) renderDebugLog(logs);
            };

            const renderStats = (data) => {
                const container = document.getElementById('stats-container');
                const tbody = document.getElementById('stats-body');

                if (!container || !tbody) {
                    console.error("Critical: Stats container/body missing from DOM");
                    return;
                }

                // 1. Show Container
                container.style.display = 'flex';

                // 2. Aggregate Data
                const stats = {};
                data.forEach(t => {
                    const k = String(t.level || 'Unknown');
                    if (!stats[k]) stats[k] = { count: 0, wins: 0, pnl: 0 };
                    stats[k].count++;
                    stats[k].pnl += t.pnlUsd;
                    if (t.pnl > 0) stats[k].wins++;
                });

                // 3. Render Rows
                tbody.innerHTML = '';
                Object.keys(stats).sort().forEach(lvl => {
                    const s = stats[lvl];
                    const winRate = ((s.wins / s.count) * 100).toFixed(0) + '%';
                    const cls = s.pnl >= 0 ? 'text-green' : 'text-red';
                    const tr = document.createElement('tr');
                    tr.innerHTML = `<td>${lvl}</td><td>${s.count}</td><td>${winRate}</td><td class="${cls}">$${s.pnl.toFixed(2)}</td>`;
                    tbody.appendChild(tr);
                });
            };

            // NEW Debug Log Render
            const renderDebugLog = (logs) => {
                const container = document.getElementById('debug-log-container');
                const tbody = document.getElementById('debug-body');
                if (!container || !tbody) return;

                if (!logs || !logs.length) {
                    container.style.display = 'none';
                    return;
                }

                container.style.display = 'block';
                tbody.innerHTML = '';
                // Show last 1000 events
                logs.slice(-1000).reverse().forEach(l => {
                    const tr = document.createElement('tr');
                    let color = '#bababa';
                    if (l.e === 'Trade') color = '#00ff00';
                    if (l.e === 'Filter') color = '#ff5555';

                    tr.innerHTML = `
                        <td style="padding: 4px; border-bottom: 1px solid #333;">${l.d}</td>
                        <td style="padding: 4px; border-bottom: 1px solid #333;">${l.t}</td>
                        <td style="padding: 4px; border-bottom: 1px solid #333; color: ${color}; font-weight: bold;">${l.e}</td>
                        <td style="padding: 4px; border-bottom: 1px solid #333; word-break: break-all;">${l.m}</td>
                    `;
                    tbody.appendChild(tr);
                });
            };





            const updateKPI = (res) => {
                try {
                    renderStats(res); // Delegate to new function

                    // KPI Logic (existing)
                    let net = 0, pts = 0, wins = 0;
                    let dayPnl = {};
                    let grossWin = 0, grossLoss = 0;
                    let winCount = 0, lossCount = 0;

                    res.forEach(t => {
                        net += t.pnlUsd;
                        pts += t.pnl;
                        if (t.pnl > 0) { wins++; grossWin += t.pnlUsd; winCount++; }
                        else { grossLoss += t.pnlUsd; lossCount++; }
                        dayPnl[t.date] = (dayPnl[t.date] || 0) + t.pnlUsd;
                    });

                    // Basic KPIs
                    const setVal = (id, txt, cls) => {
                        const el = document.getElementById(id);
                        if (el) { el.textContent = txt; if (cls) el.className = cls; }
                    };

                    setVal('kpi-pnl', '$' + net.toFixed(2), 'kpi-value ' + (net >= 0 ? 'text-green' : 'text-red'));
                    setVal('kpi-pts', pts.toFixed(2), 'kpi-value ' + (pts >= 0 ? 'text-green' : 'text-red'));
                    setVal('kpi-winrate', res.length ? ((wins / res.length) * 100).toFixed(1) + '%' : '0%');
                    setVal('kpi-count', res.length);

                    // PF & RR
                    const pf = Math.abs(grossLoss) < 0.01 ? (grossWin > 0 ? 99.99 : 0) : (grossWin / Math.abs(grossLoss));
                    setVal('kpi-pf', pf.toFixed(2), 'kpi-value ' + (pf >= 1.5 ? 'text-green' : (pf < 1 ? 'text-red' : '')));

                    const avgWin = winCount > 0 ? grossWin / winCount : 0;
                    const avgLoss = lossCount > 0 ? Math.abs(grossLoss) / lossCount : 0;
                    const rr = avgLoss < 0.01 ? 0 : (avgWin / avgLoss);
                    setVal('kpi-rr', rr.toFixed(2), 'kpi-value ' + (rr >= 2 ? 'text-green' : ''));

                    // Worst Day
                    let minVal = 0, minDate = '-';
                    for (const [d, v] of Object.entries(dayPnl)) { if (v < minVal) { minVal = v; minDate = d; } }
                    setVal('kpi-dd', `$${minVal.toFixed(2)} (${minDate})`, 'kpi-value ' + (minVal >= 0 ? 'text-green' : 'text-red'));

                    // Best Level (Quick recalc)
                    // ... (Skip complex best level logic for now to keep it safe, or reimplement simply)
                    // Actually, we can just use the renderStats logic's byproduct if we wanted, but let's keep it simple.


                    document.getElementById('results-panel').classList.remove('hidden');
                    document.getElementById('dashboard').classList.remove('hidden');

                } catch (e) {
                    console.error(e);
                    alert("KPI Error: " + e.message);
                }
            };

            const updateTable = (data) => {
                const body = document.getElementById('trade-body');
                body.innerHTML = '';
                data.forEach(t => {
                    const tr = document.createElement('tr');
                    // Colors using text-green/text-red
                    const dirClass = t.dir === 'LONG' ? 'text-green' : 'text-red';
                    const pnlClass = t.pnl >= 0 ? 'text-green' : 'text-red';
                    const usdClass = t.pnlUsd >= 0 ? 'text-green' : 'text-red';

                    tr.innerHTML = `
                        <td>${t.date}</td>
                        <td>${t.entryTime}</td>
                        <td class="${dirClass}">${t.dir}</td>
                        <td>${t.level}</td>
                        <td>${t.trigPrice.toFixed(2)}</td>
                        <td>${t.entry.toFixed(2)}</td>
                        <td>${t.exitTime}</td>
                        <td>${t.exit.toFixed(2)}</td>
                        <td>${t.mfe.toFixed(2)}</td>
                        <td class="${pnlClass}">${t.pnl.toFixed(2)}</td>
                        <td class="${usdClass}">$${t.pnlUsd.toFixed(2)}</td>
                    `;
                    body.appendChild(tr);
                });
            };

            // Sorting Logic
            document.getElementById('sort-headers').addEventListener('click', (e) => {
                if (e.target.tagName !== 'TH') return;
                const key = e.target.dataset.key;
                if (!key) return;

                // Toggle direction
                if (currentSort.key === key) {
                    currentSort.dir = currentSort.dir === 'asc' ? 'desc' : 'asc';
                } else {
                    currentSort.key = key;
                    currentSort.dir = 'asc';
                }

                // Update Header Styles
                document.querySelectorAll('#sort-headers th').forEach(th => {
                    th.classList.remove('sort-asc', 'sort-desc');
                    if (th.dataset.key === key) th.classList.add('sort-' + currentSort.dir);
                });

                // Sort Data
                const sorted = [...currentData].sort((a, b) => {
                    let valA = a[key], valB = b[key];
                    // Handle numeric strings or dates if needed, but basic compare works for most here
                    if (key === 'pnl' || key === 'pnlUsd' || key === 'entry' || key === 'exit' || key === 'trigPrice' || key === 'mfe') {
                        valA = +valA; valB = +valB;
                    }
                    if (valA < valB) return currentSort.dir === 'asc' ? -1 : 1;
                    if (valA > valB) return currentSort.dir === 'asc' ? 1 : -1;
                    return 0;
                });

                updateTable(sorted);
            });

            document.getElementById('backtest-form').addEventListener('submit', async (e) => {
                e.preventDefault();
                const f = document.getElementById('data-file').files[0];
                if (!f) return alert("Select a file!");

                const btn = document.getElementById('run-btn');
                btn.disabled = true;
                btn.querySelector('.spinner').classList.remove('hidden');

                try {
                    const raw = await parseFile(f);
                    const data = new FormData(e.target);
                    const cfg = {
                        tp: +data.get('tp_points'),
                        sl: +data.get('sl_points'),
                        off: +data.get('offset_points'),
                        hnln: document.getElementById('chk-hnln').checked,
                        npoc: document.getElementById('chk-npoc').checked,
                        hva: document.getElementById('chk-hva').checked,
                        pday: document.getElementById('chk-pday').checked,
                        dday: document.getElementById('chk-dday').checked,
                        vwap: document.getElementById('chk-vwap').checked,
                        rnd: document.getElementById('chk-rnd').checked,
                        gap: document.getElementById('chk-gap').checked,
                        useDistReset: document.getElementById('chk-dist-reset').checked,
                        distReset: parseFloat(document.getElementById('inp-reset-dist').value) || 20,
                        orFilter: document.getElementById('chk-or-filter').checked,
                        dynamicTP: document.getElementById('chk-dynamic-tp').checked,
                        sp: document.getElementById('chk-sp').checked,
                        debug: document.getElementById('chk-debug').checked,
                        slip: 0, comm: 0, tpo_day: true
                    };

                    const eng = new Strategy(raw, cfg);
                    const res = eng.run();
                    render(res, eng.debugLogs);
                } catch (x) {
                    alert(x);
                    console.error(x);
                } finally {
                    btn.disabled = false;
                    btn.querySelector('.spinner').classList.add('hidden');
                }
            });

            document.getElementById('data-file').addEventListener('change', (e) => {
                if (e.target.files[0]) document.getElementById('file-name').textContent = e.target.files[0].name;
            });
        });
    </script>
</body>

</html>